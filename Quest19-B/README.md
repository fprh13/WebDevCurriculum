# Quest 19-B. 서버 아키텍쳐 패턴

## Introduction

- 이번 퀘스트에서는 현대적인 서버 아키텍쳐 패턴에 대해 익혀 보도록 하겠습니다.

## Topics

- Microservice Architecture
- Serverless Architecture
- AWS Lambda
- Service Mesh

## Resources

- [Jeff Bezos의 이메일](https://news.hada.io/topic?id=638)
- [마이크로서비스란?](https://www.redhat.com/ko/topics/microservices/what-are-microservices)
- [AWS Lambda](https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/welcome.html)
- [AWS API Gateway](https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/welcome.html)

## Checklist

- **`마이크로서비스 아키텍쳐란 무엇일까요? 어떤 식으로 서비스를 구성할 수 있을까요? 어떤 장점을 가지고 있을까요?`**

<br>

### **💡마이크로 서비스 아키텍쳐**

<br>

> 마이크로서비스 아키텍처(MSA, Microservices Architecture)는 하나의 대규모 애플리케이션을 작은 단위의 독립적인 서비스로 분할하는 아키텍처 스타일입니다. 각 서비스는 기능별로 분리되어 작동하며, 이러한 서비스는 다른 서비스와 독립적으로 배포, 확장 및 관리됩니다.

<br>

### **💡서비스 구성 및 장단점**

<br>

**_서비스 구성_**

> 마이크로서비스 아키텍처는 애플리케이션의 모든 기능을 하나의 큰 모듈로 구현하는 모노리스 아키텍처와 대조됩니다. 마이크로서비스 아키텍처에서는 각 서비스가 API를 통해 상호작용하며, 이러한 API를 통해 애플리케이션 전체의 기능을 제공합니다.

> 서비스를 구성할 때, 마이크로서비스 아키텍처는 각 서비스가 독립적으로 배포, 확장 및 관리될 수 있도록 설계되어야 합니다. 이러한 서비스는 컨테이너화된 환경에서 동작하며, 자동화된 배포 및 관리를 위해 오케스트레이션 툴(kubernetes, Docker Swarm 등)을 사용할 수 있습니다.

<br>

**_장점_**

> 마이크로서비스 아키텍처의 가장 큰 장점은 애플리케이션의 유연성과 확장성을 높일 수 있다는 것입니다. 각 서비스가 독립적으로 배포될 수 있기 때문에, 전체 애플리케이션을 다시 빌드하거나 배포할 필요 없이 필요한 서비스만 수정하고 배포할 수 있습니다. 또한, 서비스 간의 의존성이 낮기 때문에, 각 서비스의 성능을 개별적으로 최적화하고, 실패 시 해당 서비스만 재시작하여 다른 서비스에 영향을 미치지 않습니다.

<br>

**_단점_**

> 마이크로서비스 아키텍처는 애플리케이션의 분할이 적절히 이루어지지 않거나, 서비스 간의 통신 및 데이터 일관성 등의 문제가 생길 가능성도 있습니다. 또한, 많은 수의 서비스를 관리하고 모니터링하기 위해서는 복잡한 인프라 및 운영 프로세스가 필요합니다.

<br>
<br>

- **`서버리스 아키텍쳐란 무엇일까요? 어떤 식으로 서비스를 구성할 수 있을까요? 어떤 장점을 가지고 있을까요?`**

<br>

### **💡서버리스 아키텍쳐**

<br>

> 서버리스 아키텍쳐는 서버를 직접 관리하지 않고 클라우드 서비스 업체가 제공하는 FaaS(Function as a Service)나 BaaS(Backend as a Service)와 같은 서비스를 이용하여 애플리케이션을 개발하고 운영하는 아키텍처입니다.

<br>

### **💡서비스 구성 및 장단점**

<br>

**_서비스 구성_**

> 서버리스 아키텍쳐에서는 개발자가 애플리케이션의 비즈니스 로직을 작성하는 데 집중할 수 있도록, 인프라 관리와 배포, 스케일링 등의 작업은 클라우드 서비스 업체가 대신 수행합니다. 이를 위해 개발자는 클라우드 서비스 업체가 제공하는 API나 SDK를 이용하여 필요한 기능을 사용할 수 있습니다.

> 서버리스 아키텍쳐에서는 서비스를 기능별로 분리하여 작은 단위의 함수(Function)나 마이크로서비스(Microservice)로 구성합니다. 각 함수나 마이크로서비스는 독립적으로 개발, 배포, 스케일링할 수 있기 때문에 애플리케이션 전체를 구성하는 서비스를 하나의 모놀리식(Monolithic) 애플리케이션으로 개발하는 것보다 유연하고 확장성이 높은 시스템을 구축할 수 있습니다.

<br>

**_장점_**

> 서버리스 아키텍쳐에서는 서버 인프라를 관리할 필요가 없으므로 개발자가 애플리케이션 로직에 집중할 수 있습니다.

> 요청 수에 따라 자동으로 확장하므로, 대규모 트래픽이 발생할 경우에도 스케일 업이나 다운을 신경쓸 필요가 없습니다.

> 코드 실행 시간만큼만 과금되므로 비용이 저렴하게 유지될 수 있습니다.

<br>

**_단점_**

> 서버리스 아키텍쳐에서는 모든 코드를 함수 형태로 작성해야 하므로, 기존의 모놀리틱 아키텍쳐와는 다른 방식으로 개발을 해야 합니다.

> 모든 함수가 분리되어 실행되므로 서비스 간의 통신이 많아져서 느려질 수 있습니다.

> 일부 서비스에서는 실행 시간이 긴 함수도 있을 수 있기 때문에, 이런 경우에는 서버리스 아키텍쳐보다는 전통적인 아키텍쳐를 사용하는 것이 더 적합할 수 있습니다.

<br>
<br>

- **`AWS Lambda는 어떤 서비스일까요? 이러한 서비스는 어떤 특징을 가지고, 어디에 쓰일 수 있을까요?`**

<br>

### **💡AWS Lambda**

<br>

> AWS Lambda는 서버리스 아키텍처를 기반으로 동작하는 이벤트 기반 컴퓨팅 플랫폼입니다. 개발자는 Lambda 함수를 작성하여 이벤트가 발생할 때마다 해당 함수가 실행되도록 설정할 수 있습니다. Lambda 함수는 필요한 컴퓨팅 리소스를 자동으로 프로비저닝하고, 코드를 실행한 후에는 리소스를 자동으로 제거합니다.

<br>

### **💡특징과 사용**

<br>

**_특징_**

> 서버리스 아키텍처를 기반으로 동작하므로 인프라 운영에 대한 부담이 적습니다.
> 이벤트 기반으로 동작하므로 필요한 시점에만 코드가 실행됩니다.
> 요청당 비용 청구가 이루어지므로, 비용을 효율적으로 관리할 수 있습니다.
> 다양한 프로그래밍 언어와 런타임을 지원하므로, 개발자는 자신이 선호하는 언어로 함수를 작성할 수 있습니다.

<br>

**_사용_**

> AWS Lambda는 다양한 용도로 사용될 수 있습니다. 예를 들어, 백그라운드 작업을 실행하거나, REST API의 백엔드 로직을 구현하거나, 데이터 처리 파이프라인에서 특정한 작업을 수행하는 등 다양한 용도로 사용될 수 있습니다.

<br>
<br>

- **`API Gateway는 어떤 서비스인가요? 어떤 설정을 할 수 있을까요?`**

<br>

### **💡API Gateway**

<br>

> API Gateway는 클라이언트 애플리케이션과 백엔드 서비스 간의 통신을 담당하는 서비스입니다. API Gateway는 일반적으로 RESTful API 또는 GraphQL API와 같은 API를 사용하여 클라이언트 애플리케이션과 상호 작용합니다.

<br>

### **💡설정**

<br>

> 1. **엔드포인트 설정** : API Gateway는 백엔드 서비스와 통신하기 위해 엔드포인트를 사용합니다. 엔드포인트 설정을 통해 API Gateway가 백엔드 서비스의 엔드포인트를 알 수 있습니다.

> 2. **로드 밸런싱 설정** : API Gateway는 여러 인스턴스에서 실행 중인 백엔드 서비스 간의 트래픽을 분산시키는 로드 밸런싱 기능을 제공합니다. 로드 밸런싱 설정을 통해 API Gateway가 로드 밸런싱을 수행할 때 사용할 규칙을 정의할 수 있습니다.

> 3. **인증 및 권한 부여 설정** : API Gateway는 클라이언트 애플리케이션에 대한 인증 및 권한 부여를 처리할 수 있습니다. 인증 및 권한 부여 설정을 통해 API Gateway가 사용할 인증 및 권한 부여 방법을 정의할 수 있습니다.

> 4. **API 버전 관리 설정** : API Gateway는 API의 버전 관리를 처리할 수 있습니다. API 버전 관리 설정을 통해 API의 버전을 관리하고, 이전 버전과 호환성을 유지할 수 있습니다.

> 5. **캐싱 설정** : API Gateway는 캐싱을 사용하여 반복적인 요청을 처리할 수 있습니다. 캐싱 설정을 통해 API Gateway가 캐싱을 수행할 때 사용할 규칙을 정의할 수 있습니다.

> 6. **요청/응답 변환 설정** : API Gateway는 요청과 응답을 변환하여 서로 다른 데이터 형식을 사용하는 클라이언트 애플리케이션과 백엔드 서비스 간의 통신을 용이하게 할 수 있습니다. 요청/응답 변환 설정을 통해 API Gateway가 요청과 응답을 변환하는 방법을 정의할 수 있습니다.

> 7. **모니터링 및 로깅 설정** : API Gateway는 API의 성능과 가용성을 모니터링하고, 로깅을 통해 API의 사용에 대한 정보를 수집할 수 있습니다. 모니터링 및 로깅 설정을 통해 API Gateway가 모니터링하고 로깅할 데이터를 선택할 수 있습니다.

<br>
<br>

- **`많은 마이크로서비스들을 복잡하게 연결할 경우 관리상에 어떤 난점이 생길 수 있을까요? 서비스 메쉬는 무엇이고 이러한 난점을 어떻게 해결하려는 시도일까요?`**

<br>

### **💡난점**

<br>

> 1. **네트워크 문제** : 수 많은 마이크로서비스가 통신하면서 발생하는 복잡한 네트워크 구조로 인해 네트워크 문제가 발생할 수 있습니다.

> 2. **보안 문제** : 서로 다른 마이크로서비스들이 통신하면서 보안 문제가 발생할 수 있습니다.

> 3. **모니터링 문제**: 서로 다른 마이크로서비스들이 통신하면서 각각의 로그를 수집하고 모니터링하는 것이 어렵습니다.

> 4. **유지보수 문제** : 각각의 마이크로서비스들이 독립적으로 개발 및 배포되므로, 일부 마이크로서비스가 변경되면 전체 시스템에 영향을 미칠 가능성이 있습니다.

<br>

### **💡서비스 매쉬 및 난점 해결**

<br>

**서비스 매쉬**

> 서비스 메쉬는 이러한 난점을 해결하기 위한 시도로, 서비스 간 통신을 추상화하여 각각의 마이크로서비스들이 서비스 메쉬 내에서만 통신하도록 하는 아키텍처 패턴입니다.

> 서비스 메쉬는 크게 두 가지 컴포넌트로 구성됩니다.

> 1. 사이드카 프록시: 각각의 마이크로서비스 인스턴스에 배치되는 작은 프록시 서버입니다. 사이드카 프록시는 자신이 배치된 서비스 인스턴스로의 모든 트래픽을 가로채고, 서비스 메쉬 내에서 다른 마이크로서비스로 라우팅합니다.

> 2. 컨트롤 플레인: 서비스 메쉬 내에서 모든 트래픽을 관리하고, 라우팅 정책을 관리하는 역할을 수행합니다. 컨트롤 플레인은 서비스 디스커버리, 로드 밸런싱, 트래픽 라우팅, 서비스 모니터링 등의 기능을 제공합니다.

<br>

**난점 해결**

> **서비스 디스커버리** : 서비스 메쉬는 서비스 디스커버리를 추상화하고, 서비스 디스커버리에 대한 복잡한 로직을 숨깁니다. 이를 통해 서비스 디스커버리 시스템이 단순화되고, 서비스 디스커버리에 대한 수정이나 대체가 용이해집니다.

> **로드 밸런싱** : 서비스 메쉬는 로드 밸런싱을 프록시 레이어에서 처리함으로써 서비스마다 로드 밸런서를 구성할 필요가 없어집니다. 이는 서비스 운영의 간소화와 로드 밸런싱 기능의 일관성을 보장합니다.

> **서킷 브레이킹** : 서비스 메쉬는 서킷 브레이킹을 구현하여, 서비스 간의 결합도를 낮춥니다. 이는 네트워크 지연 시스템이 전체 시스템에 영향을 주지 않도록 보호하는 기능을 합니다.

> **트래픽 제어** : 서비스 메쉬는 트래픽 제어를 통해 과부하를 방지합니다. 트래픽 제어 기능을 통해 서비스 별로 트래픽 비율을 설정하거나, 서비스별 요청 처리량을 제한하는 등의 조치를 할 수 있습니다.

<br>
<br>

## Quest

- 메모장 시스템을 JWT 발급을 위한 마이크로서비스와 실제 비즈니스 로직을 처리하는 마이크로서비스로 나누어 보세요.
- JWT 토큰 발급의 역할을 하는 마이크로서비스를 AWS Lambda와 API Gateway를 이용하여 구축해 보세요.

## Advanced

- Istio는 어떤 툴일까요? 이 툴을 Kubernetes와 함께 사용하여 어떤 구조를 구현할 수 있을까요?
