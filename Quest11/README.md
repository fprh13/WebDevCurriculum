# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- **`RDBMS 테이블의 정규화는 무엇인가요?`**

> 관계형 데이터베이스에서 테이블의 정규화는 데이터의 중복을 최소화하고 데이터 일관성을 유지하기 위해 수행되는 프로세스입니다. 이를 통해 테이블의 구조를 재정비하여 불필요한 데이터의 중복을 제거하고 데이터를 보다 효율적으로 저장하고 검색할 수 있습니다.

---

- **`MySQL 외의 RDB에는 어떤 것들이 있나요?`**

  - `Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?`

  > 1. ORACLE

  > 2. SQL server

  > 3. PostgreSQL

  > 4. SQLite

  ***

- **`RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?`**

**인덱싱이란**

> RDBMS에서 인덱싱은 데이터베이스 테이블에서 데이터를 검색하거나 정렬하는 데 사용되는 방법입니다. 인덱스는 데이터베이스 내의 특정 컬럼(열)에 대한 빠른 검색 및 데이터 정렬을 가능하게 하며, 인덱스를 사용하면 검색 속도를 크게 향상시킬 수 있습니다.

**다른 점과 동작 과정**

> 인덱스를 사용하지 않으면 테이블의 모든 레코드를 순차적으로 읽어야 하므로 검색 속도가 느리고, 대규모 데이터베이스에서는 검색 시간이 길어질 수 있습니다.인덱스는 일반적으로 B-트리나 B+트리라는 데이터 구조를 사용하여 구현됩니다. 이러한 데이터 구조는 데이터베이스의 빠른 검색을 지원하기 위해 설계된 데이터 구조입니다. 인덱스에는 인덱스 키와 해당 키가 가리키는 레코드의 위치 정보가 저장됩니다.

---

- **`ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?`**

**장점**

> 생산성 향상: ORM을 사용하면 SQL 쿼리 작성 및 결과 처리 코드를 직접 작성하지 않아도 되므로 개발자가 애플리케이션의 비즈니스 로직에 집중할 수 있습니다.

> 유지보수성 향상: ORM은 데이터베이스와의 상호 작용을 추상화하기 때문에 데이터베이스 스키마 변경에 대한 대응이 용이합니다.

> 객체 지향적인 코드 작성: ORM을 사용하면 데이터베이스 테이블과 연관된 객체를 직접 다룰 수 있으므로, 객체 지향적인 코드 작성이 가능합니다.

> 보안성 향상: ORM은 SQL Injection 공격으로부터 보호해주는 등 보안성이 높은 코드를 작성할 수 있도록 도와줍니다.

**단점**

> 성능 저하: ORM은 추상화된 객체와 데이터베이스 간의 매핑을 수행하기 때문에, 일부 상황에서는 SQL 쿼리를 직접 작성한 것보다 성능이 저하될 수 있습니다.

> 학습 비용: ORM을 사용하려면 ORM 도구를 이해하고 사용하는 방법을 배워야 하므로 학습 비용이 발생합니다.

> 제한적인 기능: ORM은 데이터베이스의 모든 기능을 지원하지 않을 수 있습니다. 특히 복잡한 데이터 모델링을 다룰 때 제한적인 기능을 보일 수 있습니다.

- `자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?`

> 1. Sequelize

> 2. TYPEORM

> 3. PRISMA

> 4. Mongoose

> 5. Waterline

> 6. Bookshelf

> 7. Objection

---

- **`모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?`**

> **1:1** (One-to-One) 관계: 한 모델의 하나의 인스턴스가 다른 모델의 하나의 인스턴스와 매칭되는 경우입니다. 예를 들면 사용자(User)와 프로필(Profile)이 있을 때, 사용자 한 명은 하나의 프로필만 가질 수 있다는 것입니다. 이 관계는 두 모델 중 하나의 모델에 외래키(Foreign Key)를 추가하여 맺을 수 있습니다.

> **1:N** (One-to-Many) 관계: 한 모델의 하나의 인스턴스가 다른 모델의 여러 인스턴스와 매칭되는 경우입니다. 예를 들면 게시글(Post)과 댓글(Comment)이 있을 때, 하나의 게시글에는 여러 개의 댓글이 달릴 수 있다는 것입니다. 이 관계는 다수 쪽 모델에서 외래키(Foreign Key)를 추가하여 맺을 수 있습니다.

> **N:M** (Many-to-Many) 관계: 두 모델의 하나의 인스턴스가 서로 다수의 인스턴스와 매칭되는 경우입니다. 예를 들면 강의(Course)와 학생(Student)이 있을 때, 하나의 강의는 여러 학생이 수강할 수 있고, 하나의 학생은 여러 강의를 수강할 수 있다는 것입니다. 이 관계는 두 모델 각각에 대한 중간 테이블(Intermediate Table)을 만들어, 각 모델에서 외래키(Foreign Key)를 추가하여 맺을 수 있습니다.

---

- **`DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?`**

> 해시 함수를 사용하여 암호화하고 인증하는 것이 가능하기 때문입니다.

- `해시 함수에는 어떤 것이 있나요?`

> MD5, SHA-256, SHA-384, SHA-512 등

- `사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?`

> 사용자의 암호를 해싱하여 저장할 때에는 단순히 해시 함수를 적용하여 저장하는 것보다 더 안전한 방법이 필요합니다. 대표적인 방법으로는 솔트(salt)를 이용한 해싱 방법이 있습니다. (ex : PBKDF2)

---

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
